import "./chunk-V4OQ3NZ2.js";

// node_modules/vue-swipe-actions/src/utils/event.js
var listenOpts = {};
Object.defineProperty(listenOpts, "passive", {
  configurable: true,
  get() {
    let passive;
    try {
      const opts = Object.defineProperty({}, "passive", {
        // eslint-disable-next-line getter-return
        get() {
          passive = { passive: true };
        }
      });
      window.addEventListener("qtest", null, opts);
      window.removeEventListener("qtest", null, opts);
    } catch (e) {
    }
    listenOpts.passive = passive;
    return passive;
  },
  set(val) {
    Object.defineProperty(this, "passive", {
      value: val
    });
  }
});
function leftClick(e) {
  return e.button === 0;
}
function position(e) {
  if (e.touches && e.touches[0])
    e = e.touches[0];
  else if (e.changedTouches && e.changedTouches[0])
    e = e.changedTouches[0];
  return {
    top: e.clientY,
    left: e.clientX
  };
}

// node_modules/vue-swipe-actions/src/utils/touch-observer.js
function setObserver(el, evt, ctx) {
  const { target } = evt;
  ctx.touchTargetObserver = new MutationObserver(() => {
    if (el.contains(target) === false)
      ctx.end(evt);
  });
  ctx.touchTargetObserver.observe(el, { childList: true, subtree: true });
}
function removeObserver(ctx) {
  if (ctx.touchTargetObserver !== void 0) {
    ctx.touchTargetObserver.disconnect();
    ctx.touchTargetObserver = void 0;
  }
}

// node_modules/vue-swipe-actions/src/directives/touch-horizontal-pan.js
function getDirection(mod) {
  const none = mod.horizontal !== true && mod.vertical !== true;
  const dir = {
    all: none === true || mod.horizontal === true && mod.vertical === true
  };
  if (mod.horizontal === true || none === true)
    dir.horizontal = true;
  if (mod.vertical === true || none === true)
    dir.vertical = true;
  return dir;
}
function processChanges(evt, ctx, isFinal) {
  const pos = position(evt);
  let direction;
  const distX = pos.left - ctx.event.x;
  const distY = pos.top - ctx.event.y;
  const absDistX = Math.abs(distX);
  const absDistY = Math.abs(distY);
  if (ctx.direction.horizontal && !ctx.direction.vertical)
    direction = distX < 0 ? "left" : "right";
  else if (!ctx.direction.horizontal && ctx.direction.vertical)
    direction = distY < 0 ? "up" : "down";
  else if (absDistX >= absDistY)
    direction = distX < 0 ? "left" : "right";
  else
    direction = distY < 0 ? "up" : "down";
  return {
    evt,
    position: pos,
    direction,
    isFirst: ctx.event.isFirst,
    isFinal: isFinal === true,
    isMouse: ctx.event.mouse,
    duration: (/* @__PURE__ */ new Date()).getTime() - ctx.event.time,
    distance: {
      x: absDistX,
      y: absDistY
    },
    offset: {
      x: distX,
      y: distY
    },
    delta: {
      x: pos.left - ctx.event.lastX,
      y: pos.top - ctx.event.lastY
    }
  };
}
function shouldTrigger(ctx, changes) {
  if (ctx.direction.horizontal && ctx.direction.vertical)
    return true;
  if (ctx.direction.horizontal && !ctx.direction.vertical)
    return Math.abs(changes.delta.x) > 0;
  if (!ctx.direction.horizontal && ctx.direction.vertical)
    return Math.abs(changes.delta.y) > 0;
  return void 0;
}
var touch_horizontal_pan_default = {
  name: "touch-pan",
  bind(el, binding) {
    const mouse = binding.modifiers.mouse === true;
    const mouseEvtPassive = binding.modifiers.mouseMightPrevent !== true && binding.modifiers.mousePrevent !== true;
    const mouseEvtOpts = listenOpts.passive === void 0 ? true : { passive: mouseEvtPassive, capture: true };
    const touchEvtPassive = binding.modifiers.mightPrevent !== true && binding.modifiers.prevent !== true;
    const touchEvtOpts = touchEvtPassive ? listenOpts.passive : null;
    function handleEvent(evt, mouseEvent) {
      if (mouse && mouseEvent) {
        if (binding.modifiers.mouseStop) evt.stopPropagation();
        if (binding.modifiers.mousePrevent) evt.preventDefault();
      } else {
        if (binding.modifiers.stop) evt.stopPropagation();
        if (binding.modifiers.prevent) evt.preventDefault();
      }
    }
    const ctx = {
      handler: binding.value,
      direction: getDirection(binding.modifiers),
      mouseStart(evt) {
        if (leftClick(evt)) {
          document.addEventListener("mousemove", ctx.move, mouseEvtOpts);
          document.addEventListener("mouseup", ctx.mouseEnd, mouseEvtOpts);
          ctx.start(evt, true);
        }
      },
      mouseEnd(evt) {
        document.removeEventListener("mousemove", ctx.move, mouseEvtOpts);
        document.removeEventListener("mouseup", ctx.mouseEnd, mouseEvtOpts);
        ctx.end(evt);
      },
      start(evt, mouseEvent) {
        removeObserver(ctx);
        if (mouseEvent !== true)
          setObserver(el, evt, ctx);
        const pos = position(evt);
        ctx.event = {
          x: pos.left,
          y: pos.top,
          time: (/* @__PURE__ */ new Date()).getTime(),
          mouse: mouseEvent === true,
          detected: false,
          abort: false,
          isFirst: true,
          isFinal: false,
          lastX: pos.left,
          lastY: pos.top
        };
      },
      move(evt) {
        if (!ctx.event)
          return;
        if (ctx.event.abort === true)
          return;
        if (ctx.event.detected === true) {
          handleEvent(evt, ctx.event.mouse);
          const changes = processChanges(evt, ctx, false);
          if (shouldTrigger(ctx, changes)) {
            ctx.handler(changes);
            ctx.event.lastX = changes.position.left;
            ctx.event.lastY = changes.position.top;
            ctx.event.isFirst = false;
          }
          return;
        }
        const pos = position(evt);
        const distX = Math.abs(pos.left - ctx.event.x);
        const distY = Math.abs(pos.top - ctx.event.y);
        if (distX === distY)
          return;
        ctx.event.detected = true;
        if (ctx.direction.all === false && (ctx.event.mouse === false || binding.modifiers.mouseAllDir !== true))
          ctx.event.abort = ctx.direction.vertical ? distX > distY : distX < distY;
        if (ctx.event.abort !== true) {
          document.documentElement.style.cursor = "grabbing";
          document.body.classList.add("swipeout-no-pointer-events");
          document.body.classList.add("swipeout-non-selectable");
        }
        ctx.move(evt);
      },
      end(evt) {
        if (!ctx.event)
          return;
        if (ctx.event.mouse !== true) removeObserver(ctx);
        document.documentElement.style.cursor = "";
        document.body.classList.remove("swipeout-no-pointer-events");
        document.body.classList.remove("swipeout-non-selectable");
        if (ctx.event.abort === true || ctx.event.detected !== true || ctx.event.isFirst === true)
          return;
        handleEvent(evt, ctx.event.mouse);
        ctx.handler(processChanges(evt, ctx, true));
      }
    };
    if (el.__qtouchpan)
      el.__qtouchpan_old = el.__qtouchpan;
    el.__qtouchpan = ctx;
    if (mouse === true)
      el.addEventListener("mousedown", ctx.mouseStart, mouseEvtOpts);
    el.addEventListener("touchstart", ctx.start, touchEvtOpts);
    el.addEventListener("touchmove", ctx.move, touchEvtOpts);
    el.addEventListener("touchcancel", ctx.end, touchEvtOpts);
    el.addEventListener("touchend", ctx.end, touchEvtOpts);
  },
  update(el, { oldValue, value, modifiers }) {
    const ctx = el.__qtouchpan;
    if (oldValue !== value)
      ctx.handler = value;
    if (modifiers.horizontal !== ctx.direction.horizontal || modifiers.vertical !== ctx.direction.vertical)
      ctx.direction = getDirection(modifiers);
  },
  unbind(el, binding) {
    const ctx = el.__qtouchpan_old || el.__qtouchpan;
    if (ctx !== void 0) {
      removeObserver(ctx);
      document.documentElement.style.cursor = "";
      document.body.classList.remove("swipeout-no-pointer-events");
      document.body.classList.remove("swipeout-non-selectable");
      const mouse = binding.modifiers.mouse === true;
      const mouseEvtPassive = binding.modifiers.mouseMightPrevent !== true && binding.modifiers.mousePrevent !== true;
      const mouseEvtOpts = listenOpts.passive === void 0 ? true : { passive: mouseEvtPassive, capture: true };
      const touchEvtPassive = binding.modifiers.mightPrevent !== true && binding.modifiers.prevent !== true;
      const touchEvtOpts = touchEvtPassive ? listenOpts.passive : null;
      if (mouse === true) {
        el.removeEventListener("mousedown", ctx.mouseStart, mouseEvtOpts);
        document.removeEventListener("mousemove", ctx.move, mouseEvtOpts);
        document.removeEventListener("mouseup", ctx.mouseEnd, mouseEvtOpts);
      }
      el.removeEventListener("touchstart", ctx.start, touchEvtOpts);
      el.removeEventListener("touchmove", ctx.move, touchEvtOpts);
      el.removeEventListener("touchcancel", ctx.end, touchEvtOpts);
      el.removeEventListener("touchend", ctx.end, touchEvtOpts);
      delete el[el.__qtouchpan_old ? "__qtouchpan_old" : "__qtouchpan"];
    }
  }
};

// node_modules/vue-swipe-actions/src/components/SwipeOut.js
function translateX(x) {
  if (x === 0)
    return "";
  return `translate3d(${x}px, 0, 0)`;
}
function clientWidth(ref) {
  return ref ? ref.clientWidth : 0;
}
function areEqual(a, b) {
  if (!a && !b)
    return true;
  return a === b;
}
var SwipeOut_default = {
  name: "SwipeOut",
  directives: {
    touchPan: touch_horizontal_pan_default
  },
  props: {
    threshold: {
      type: Number,
      default: 45
    },
    revealed: {
      type: [String, Boolean]
    },
    /**
    * Is the item disabled
    */
    disabled: {
      type: Boolean,
      default: false
    },
    passiveListeners: {
      type: Boolean,
      default: false
    }
  },
  watch: {
    revealed(val) {
      if (this.innerRevealed === val)
        return;
      this._reveal(val, true);
    }
  },
  data() {
    return {
      innerRevealed: this.revealed || false
    };
  },
  methods: {
    // public
    /**
     * @deprecated use ```close``` instead...
     */
    closeActions() {
      this.close();
    },
    close() {
      if (this._isActive)
        return;
      this._reveal(false, true);
    },
    revealLeft() {
      if (this._isActive || !this.$refs.left)
        return;
      this._reveal("left", true);
    },
    revealRight() {
      if (this._isActive || !this.$refs.right)
        return;
      this._reveal("right", true);
    },
    // private
    _distanceSwiped() {
      const contentRect = this.$refs.content.getBoundingClientRect();
      const elementRect = this.$el.getBoundingClientRect();
      return contentRect.left - elementRect.left - this.$el.clientLeft;
    },
    _onPan(pan) {
      if (this.disabled)
        return null;
      if (pan.isFirst)
        return this._startListener(pan);
      if (!this._isActive)
        return null;
      if (pan.isFinal)
        return this._stopListener(pan);
      return this._swipeListener(pan);
    },
    _startListener({ distance }) {
      this.$el.classList.add("swipeout--no-transition");
      if (distance.y <= 5) {
        this._leftActionsWidth = this.$refs.left ? this.$refs.left.clientWidth : 0;
        this._rightActionsWidth = this.$refs.right ? this.$refs.right.clientWidth : 0;
        this._startLeft = this._distanceSwiped();
        this._isActive = true;
        this.$emit("active", true);
        clearTimeout(this._timer);
      }
    },
    _swipeListener({ offset }) {
      const newX = offset.x + this._startLeft;
      if (!this.$scopedSlots.left && newX > 0)
        return this._animateSlide(0);
      if (!this.$scopedSlots.right && newX < 0)
        return this._animateSlide(0);
      return this._animateSlide(offset.x + this._startLeft);
    },
    _stopListener({ offset, distance }) {
      this.$el.classList.remove("swipeout--no-transition");
      this._isActive = false;
      this.$emit("active", false);
      const newX = this._startLeft + offset.x;
      if (this._startLeft === 0 && Math.abs(newX) <= this.threshold || distance.x >= this.threshold && (this._startLeft > 0 && distance.x < this._leftActionsWidth || this._startLeft < 0 && distance.x < this._rightActionsWidth))
        return this._reveal(false);
      return this._reveal(newX > 0 ? "left" : "right");
    },
    _reveal(dir, recalculateWidth) {
      if (this._isActive && areEqual(this.innerRevealed, dir))
        return;
      if (dir && !this.$refs[dir])
        dir = false;
      this.innerRevealed = dir;
      this.$emit("update:revealed", dir);
      if (!dir) {
        this._animateSlide(0);
        this.$emit("closed");
        return;
      }
      if (dir === "left" && this.$refs.left) {
        this._leftActionsWidth = recalculateWidth ? clientWidth(this.$refs.left) : this._leftActionsWidth;
        this._animateSlide(this._leftActionsWidth);
        this.$emit("revealed", { side: "left", close: this.closeActions });
        this.$emit("leftRevealed", { close: this.closeActions });
        return;
      }
      if (dir === "right" && this.$refs.right) {
        this._rightActionsWidth = recalculateWidth ? clientWidth(this.$refs.right) : this._rightActionsWidth;
        this._animateSlide(-this._rightActionsWidth);
        this.$emit("revealed", { side: "right", close: this.closeActions });
        this.$emit("rightRevealed", { close: this.closeActions });
      }
    },
    // shift actions
    _shiftLeftActions(newX) {
      if (!this.$scopedSlots.left)
        return;
      if (newX < 0)
        newX = 0;
      const actions = this.$refs.left;
      const actionsWidth = this._leftActionsWidth;
      const progress = 1 - Math.min(newX / actionsWidth, 1);
      const deltaX = Math.min(newX, actionsWidth);
      const { children } = actions;
      const { length } = children;
      for (let i = 0; i < length; i++) {
        const child = children[i];
        const offsetLeft = actionsWidth - child.offsetLeft - child.offsetWidth;
        child.style.transform = translateX(deltaX + offsetLeft * progress);
        if (length > 1)
          child.style.zIndex = `${length - i}`;
      }
    },
    _shiftRightActions(newX) {
      if (!this.$scopedSlots.right)
        return;
      if (newX > 0)
        newX = 0;
      const actions = this.$refs.right;
      const actionsWidth = this._rightActionsWidth;
      const progress = 1 + Math.max(newX / actionsWidth, -1);
      const deltaX = Math.max(newX, -actionsWidth);
      const { children } = actions;
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        child.style.transform = translateX(deltaX - child.offsetLeft * progress);
      }
    },
    _animateSlide(to) {
      cancelAnimationFrame(this._frame);
      this._frame = requestAnimationFrame(() => {
        this.$refs.content.style.transform = translateX(to);
        this._shiftLeftActions(to);
        this._shiftRightActions(to);
      });
    }
  },
  render(h) {
    const content = [];
    const { left, right, default: defaultScope } = this.$scopedSlots;
    if (left)
      content.push(
        h("div", {
          ref: "left",
          staticClass: "swipeout-left"
        }, left({
          close: this.closeActions
        }))
      );
    if (right)
      content.push(
        h("div", {
          ref: "right",
          staticClass: "swipeout-right"
        }, right({
          close: this.closeActions
        }))
      );
    content.push(
      h("div", {
        ref: "content",
        staticClass: "swipeout-content",
        directives: !this.disabled && (left || right) ? [{
          name: "touch-pan",
          value: this._onPan,
          modifiers: {
            horizontal: true,
            mouse: true,
            prevent: !this.passiveListeners,
            mousePrevent: true
          }
        }] : null
      }, defaultScope ? defaultScope({
        revealLeft: this.revealLeft,
        revealRight: this.revealRight,
        disabled: this.disabled,
        close: this.closeActions,
        revealed: this.innerRevealed
      }) : null)
    );
    return h("div", {
      staticClass: "swipeout",
      class: { "swipeout--disabled": this.disabled }
    }, content);
  },
  beforeDestroy() {
    clearTimeout(this._timer);
    cancelAnimationFrame(this._frame);
  }
};

// node_modules/vue-swipe-actions/src/components/SwipeList.js
var SwipeList_default = {
  name: "SwipeList",
  props: {
    items: {
      type: Array,
      required: true
    },
    itemKey: {
      type: String
    },
    /**
     * @deprecated since version 2.0 - use itemKey instead
     */
    transitionKey: {
      type: String
    },
    threshold: {
      type: Number,
      default: 45
    },
    revealed: {
      type: Object
    },
    disabled: {
      type: Boolean,
      default: false
    },
    itemDisabled: {
      type: Function,
      default: () => false
    },
    passiveListeners: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      innerRevealed: this.revealed || {},
      rev: this.items.map(() => null)
    };
  },
  watch: {
    revealed(val) {
      this.innerRevealed = val;
    },
    items() {
      this._emitRevealed({});
    }
  },
  methods: {
    revealRight(index) {
      if (!this.$refs.items[index])
        return;
      this.$refs.items[index].revealRight();
    },
    revealLeft(index) {
      if (!this.$refs.items[index])
        return;
      this.$refs.items[index].revealLeft();
    },
    close(index) {
      if (!this.$refs.items)
        return;
      if (index === void 0)
        return this.$refs.items.forEach((i) => i.close());
      if (!this.$refs.items[index])
        return;
      return this.$refs.items[index].close();
    },
    isRevealed(index) {
      return this.innerRevealed[index] || false;
    },
    /**
     * @deprecated use ```close``` instead
     */
    closeActions(index) {
      this.close(index);
    },
    // private
    /*
    _updateRevealed(item, index, side) {
    	const key = this._getItemKey(item, index);
    	if (side)
    		return this.$set(this.innerRevealed, key, side);
    	return this.$delete(this.innerRevealed, key);
    },
    */
    _onReveal(item, index, event) {
      this.$emit("revealed", {
        index,
        item,
        side: event.side,
        close: event.close
      });
      this._emitRevealed({
        ...this.innerRevealed,
        [index]: event.side
      });
    },
    _onClose(item, index) {
      this.$emit("closed", {
        index,
        item
      });
      const { [index]: omit, ...newRevealed } = this.innerRevealed;
      this._emitRevealed(newRevealed);
    },
    _getItemKey(item, index) {
      const keyPropery = this.itemKey || this.transitionKey;
      if (keyPropery !== void 0)
        return item[this.itemKey || this.transitionKey];
      return index;
    },
    _emitRevealed(val) {
      if (this.revealed !== void 0) {
        this.$emit("update:revealed", val);
        return;
      }
      this.innerRevealed = val;
    },
    __renderItem(h, item, index) {
      const { left, right, default: defaultScope } = this.$scopedSlots;
      const scopedSlots = {};
      if (left)
        scopedSlots.left = ({ close }) => left({ item, close, index });
      if (right)
        scopedSlots.right = ({ close }) => right({ item, close, index });
      scopedSlots.default = ({
        close,
        disabled,
        revealLeft,
        revealRight,
        revealed
      }) => h(
        "div",
        {
          ref: "itemsContent",
          on: {
            click: () => this.$emit("swipeout:click", item)
          }
        },
        defaultScope({
          item,
          index,
          close,
          disabled,
          revealed,
          revealLeft,
          revealRight
        })
      );
      return h(SwipeOut_default, {
        key: index,
        ref: "items",
        refInFor: true,
        staticClass: "swipeout-list-item",
        props: {
          disabled: this.disabled || this.itemDisabled(item),
          threshold: this.threshold,
          revealed: this.innerRevealed[index],
          passiveListeners: this.passiveListeners
        },
        on: {
          revealed: ($event) => this._onReveal(item, index, $event),
          leftRevealed: ($event) => this.$emit("leftRevealed", { index, item, close: $event.close }),
          rightRevealed: ($event) => this.$emit("rightRevealed", { index, item, close: $event.close }),
          closed: ($event) => this._onClose(item, index, $event),
          active: ($event) => this.$emit("active", $event)
        },
        scopedSlots
      });
    }
  },
  render(h) {
    return h("div", {
      staticClass: "swipeout-list",
      class: { "swipeout--disabled": this.disabled }
    }, this.items.map((item, index) => this.__renderItem(h, item, index)));
  }
};

// node_modules/vue-swipe-actions/src/index.esm.js
var index_esm_default = {
  install(Vue) {
    Vue.component("SwipeList", SwipeList_default);
    Vue.component("SwipeOut", SwipeOut_default);
  },
  SwipeList: SwipeList_default,
  SwipeOut: SwipeOut_default
};
export {
  SwipeList_default as SwipeList,
  SwipeOut_default as SwipeOut,
  index_esm_default as default
};
//# sourceMappingURL=vue-swipe-actions.js.map
