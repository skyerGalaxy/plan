/*!
 * vue-swipe-actions v2.0.0-beta.20
 * (c) 2016-present eCollect
 * Released under the MIT License.
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('vue')) :
	typeof define === 'function' && define.amd ? define(['vue'], factory) :
	(global = global || self, global['vue-swipe-actions'] = factory(global.Vue));
}(this, (function (Vue) { 'use strict';

 if (Vue === void 0) {
	  console.error('[ Quasar ] Vue is required to run. Please add a script tag for it before loading Quasar.')
	  return
	}
	Vue = Vue && Vue.hasOwnProperty('default') ? Vue['default'] : Vue;

	// adpoted from https://github.com/quasarframework/quasar/blob/dev/quasar/src/utils/event.js
	var listenOpts = {};
	Object.defineProperty(listenOpts, 'passive', {
		configurable: true,
		get: function get() {
			var passive;

			try {
				var opts = Object.defineProperty({}, 'passive', {
					// eslint-disable-next-line getter-return
					get: function get() {
						passive = { passive: true };
					},
				});
				window.addEventListener('qtest', null, opts);
				window.removeEventListener('qtest', null, opts);
			} catch (e) {
				// do nothing
			}

			listenOpts.passive = passive;
			return passive;
		},
		set: function set(val) {
			Object.defineProperty(this, 'passive', {
				value: val,
			});
		},
	});

	function leftClick(e) {
		return e.button === 0;
	}

	function position(e) {
		if (e.touches && e.touches[0])
			// eslint-disable-next-line prefer-destructuring
			{ e = e.touches[0]; }
		else if (e.changedTouches && e.changedTouches[0])
			// eslint-disable-next-line prefer-destructuring
			{ e = e.changedTouches[0]; }


		return {
			top: e.clientY,
			left: e.clientX,
		};
	}

	// taken from https://github.com/quasarframework/quasar/blob/dev/quasar/src/utils/touch-observer.js
	function setObserver(el, evt, ctx) {
		var target = evt.target;
		ctx.touchTargetObserver = new MutationObserver(function () {
			if (el.contains(target) === false)
				{ ctx.end(evt); }
		});
		ctx.touchTargetObserver.observe(el, { childList: true, subtree: true });
	}

	function removeObserver(ctx) {
		if (ctx.touchTargetObserver !== undefined) {
			ctx.touchTargetObserver.disconnect();
			ctx.touchTargetObserver = undefined;
		}
	}

	// adopted from https://github.com/quasarframework/quasar/blob/dev/quasar/src/directives/TouchPan.js

	function getDirection(mod) {
		var none = mod.horizontal !== true && mod.vertical !== true;
		var dir = {
			all: none === true || (mod.horizontal === true && mod.vertical === true),
		};

		if (mod.horizontal === true || none === true)
			{ dir.horizontal = true; }

		if (mod.vertical === true || none === true)
			{ dir.vertical = true; }


		return dir;
	}

	function processChanges(evt, ctx, isFinal) {
		var
			pos = position(evt);
		var direction;
		var distX = pos.left - ctx.event.x;
		var distY = pos.top - ctx.event.y;
		var absDistX = Math.abs(distX);
		var absDistY = Math.abs(distY);

		if (ctx.direction.horizontal && !ctx.direction.vertical)
			{ direction = distX < 0 ? 'left' : 'right'; }
		else if (!ctx.direction.horizontal && ctx.direction.vertical)
			{ direction = distY < 0 ? 'up' : 'down'; }
		else if (absDistX >= absDistY)
			{ direction = distX < 0 ? 'left' : 'right'; }
		else
			{ direction = distY < 0 ? 'up' : 'down'; }


		return {
			evt: evt,
			position: pos,
			direction: direction,
			isFirst: ctx.event.isFirst,
			isFinal: isFinal === true,
			isMouse: ctx.event.mouse,
			duration: new Date().getTime() - ctx.event.time,
			distance: {
				x: absDistX,
				y: absDistY,
			},
			offset: {
				x: distX,
				y: distY,
			},
			delta: {
				x: pos.left - ctx.event.lastX,
				y: pos.top - ctx.event.lastY,
			},
		};
	}

	function shouldTrigger(ctx, changes) {
		if (ctx.direction.horizontal && ctx.direction.vertical)
			{ return true; }

		if (ctx.direction.horizontal && !ctx.direction.vertical)
			{ return Math.abs(changes.delta.x) > 0; }

		if (!ctx.direction.horizontal && ctx.direction.vertical)
			{ return Math.abs(changes.delta.y) > 0; }

		return undefined;
	}

	var touchPan = {
		name: 'touch-pan',

		bind: function bind(el, binding) {
			var
				mouse = binding.modifiers.mouse === true;
			var mouseEvtPassive = binding.modifiers.mouseMightPrevent !== true && binding.modifiers.mousePrevent !== true;
			var mouseEvtOpts = listenOpts.passive === undefined ? true : { passive: mouseEvtPassive, capture: true };
			var touchEvtPassive = binding.modifiers.mightPrevent !== true && binding.modifiers.prevent !== true;
			var touchEvtOpts = touchEvtPassive ? listenOpts.passive : null;

			function handleEvent(evt, mouseEvent) {
				if (mouse && mouseEvent) {
					if (binding.modifiers.mouseStop) { evt.stopPropagation(); }
					if (binding.modifiers.mousePrevent) { evt.preventDefault(); }
				} else {
					if (binding.modifiers.stop) { evt.stopPropagation(); }
					if (binding.modifiers.prevent) { evt.preventDefault(); }
				}
			}

			var ctx = {
				handler: binding.value,
				direction: getDirection(binding.modifiers),

				mouseStart: function mouseStart(evt) {
					if (leftClick(evt)) {
						document.addEventListener('mousemove', ctx.move, mouseEvtOpts);
						document.addEventListener('mouseup', ctx.mouseEnd, mouseEvtOpts);
						ctx.start(evt, true);
					}
				},

				mouseEnd: function mouseEnd(evt) {
					document.removeEventListener('mousemove', ctx.move, mouseEvtOpts);
					document.removeEventListener('mouseup', ctx.mouseEnd, mouseEvtOpts);
					ctx.end(evt);
				},

				start: function start(evt, mouseEvent) {
					removeObserver(ctx);
					if (mouseEvent !== true)
						{ setObserver(el, evt, ctx); }

					var pos = position(evt);

					ctx.event = {
						x: pos.left,
						y: pos.top,
						time: new Date().getTime(),
						mouse: mouseEvent === true,
						detected: false,
						abort: false,
						isFirst: true,
						isFinal: false,
						lastX: pos.left,
						lastY: pos.top,
					};
				},

				move: function move(evt) {
					if (!ctx.event)
						{ return; }

					if (ctx.event.abort === true)
						{ return; }


					if (ctx.event.detected === true) {
						handleEvent(evt, ctx.event.mouse);

						var changes = processChanges(evt, ctx, false);
						if (shouldTrigger(ctx, changes)) {
							ctx.handler(changes);
							ctx.event.lastX = changes.position.left;
							ctx.event.lastY = changes.position.top;
							ctx.event.isFirst = false;
						}

						return;
					}

					var
						pos = position(evt);
					var distX = Math.abs(pos.left - ctx.event.x);
					var distY = Math.abs(pos.top - ctx.event.y);

					if (distX === distY)
						{ return; }


					ctx.event.detected = true;

					if (ctx.direction.all === false && (ctx.event.mouse === false || binding.modifiers.mouseAllDir !== true))
						{ ctx.event.abort = ctx.direction.vertical
							? distX > distY
							: distX < distY; }


					if (ctx.event.abort !== true) {
						document.documentElement.style.cursor = 'grabbing';
						document.body.classList.add('swipeout-no-pointer-events');
						document.body.classList.add('swipeout-non-selectable');
						// clearSelection();
					}

					ctx.move(evt);
				},

				end: function end(evt) {
					if (!ctx.event)
						{ return; }

					if (ctx.event.mouse !== true) { removeObserver(ctx); }

					document.documentElement.style.cursor = '';
					document.body.classList.remove('swipeout-no-pointer-events');
					document.body.classList.remove('swipeout-non-selectable');

					if (ctx.event.abort === true || ctx.event.detected !== true || ctx.event.isFirst === true)
						{ return; }


					handleEvent(evt, ctx.event.mouse);
					ctx.handler(processChanges(evt, ctx, true));
				},
			};

			if (el.__qtouchpan)
				{ el.__qtouchpan_old = el.__qtouchpan; }


			el.__qtouchpan = ctx;

			if (mouse === true)
				{ el.addEventListener('mousedown', ctx.mouseStart, mouseEvtOpts); }

			el.addEventListener('touchstart', ctx.start, touchEvtOpts);
			el.addEventListener('touchmove', ctx.move, touchEvtOpts);
			el.addEventListener('touchcancel', ctx.end, touchEvtOpts);
			el.addEventListener('touchend', ctx.end, touchEvtOpts);
		},

		update: function update(el, ref) {
			var oldValue = ref.oldValue;
			var value = ref.value;
			var modifiers = ref.modifiers;

			var ctx = el.__qtouchpan;

			if (oldValue !== value)
				{ ctx.handler = value; }


			if (
				(modifiers.horizontal !== ctx.direction.horizontal)
	      || (modifiers.vertical !== ctx.direction.vertical)
			)
				{ ctx.direction = getDirection(modifiers); }
		},

		unbind: function unbind(el, binding) {
			var ctx = el.__qtouchpan_old || el.__qtouchpan;
			if (ctx !== undefined) {
				removeObserver(ctx);

				document.documentElement.style.cursor = '';
				document.body.classList.remove('swipeout-no-pointer-events');
				document.body.classList.remove('swipeout-non-selectable');

				var
					mouse = binding.modifiers.mouse === true;
				var mouseEvtPassive = binding.modifiers.mouseMightPrevent !== true && binding.modifiers.mousePrevent !== true;
				var mouseEvtOpts = listenOpts.passive === undefined ? true : { passive: mouseEvtPassive, capture: true };
				var touchEvtPassive = binding.modifiers.mightPrevent !== true && binding.modifiers.prevent !== true;
				var touchEvtOpts = touchEvtPassive ? listenOpts.passive : null;

				if (mouse === true) {
					el.removeEventListener('mousedown', ctx.mouseStart, mouseEvtOpts);
					document.removeEventListener('mousemove', ctx.move, mouseEvtOpts);
					document.removeEventListener('mouseup', ctx.mouseEnd, mouseEvtOpts);
				}
				el.removeEventListener('touchstart', ctx.start, touchEvtOpts);
				el.removeEventListener('touchmove', ctx.move, touchEvtOpts);
				el.removeEventListener('touchcancel', ctx.end, touchEvtOpts);
				el.removeEventListener('touchend', ctx.end, touchEvtOpts);

				delete el[el.__qtouchpan_old ? '__qtouchpan_old' : '__qtouchpan'];
			}
		},
	};

	// eslint-disable-next-line no-unused-vars
	// import styles from '../styles/vue-swipe-actions.css';

	function translateX(x) {
		if (x === 0)
			{ return ''; }

		return ("translate3d(" + x + "px, 0, 0)");
	}

	function clientWidth(ref) {
		return ref ? ref.clientWidth : 0;
	}

	// eslint-disable-next-line no-unused-vars
	function areEqual(a, b) {
		if (!a && !b)
			{ return true; }
		return a === b;
	}

	var SwipeOut = {
		name: 'SwipeOut',
		directives: {
			touchPan: touchPan,
		},
		props: {
			threshold: {
				type: Number,
				default: 45,
			},
			revealed: {
				type: [String, Boolean],
			},
			/**
			* Is the item disabled
			*/
			disabled: {
				type: Boolean,
				default: false,
			},
			passiveListeners: {
				type: Boolean,
				default: false,
			},
		},
		watch: {
			revealed: function revealed(val) {
				if (this.innerRevealed === val)
					{ return; }
				this._reveal(val, true);
			},
		},
		data: function data() {
			return {
				innerRevealed: this.revealed || false,
			};
		},
		methods: {
			// public
			/**
			 * @deprecated use ```close``` instead...
			 */
			closeActions: function closeActions() {
				this.close();
			},
			close: function close() {
				if (this._isActive)
					{ return; }

				this._reveal(false, true);
			},
			revealLeft: function revealLeft() {
				if (this._isActive || !this.$refs.left)
					{ return; }

				this._reveal('left', true);
			},
			revealRight: function revealRight() {
				if (this._isActive || !this.$refs.right)
					{ return; }

				this._reveal('right', true);
			},
			// private
			_distanceSwiped: function _distanceSwiped() {
				var contentRect = this.$refs.content.getBoundingClientRect();
				var elementRect = this.$el.getBoundingClientRect();
				return contentRect.left - elementRect.left - this.$el.clientLeft;
			},
			_onPan: function _onPan(pan) {
				if (this.disabled)
					{ return null; }

				if (pan.isFirst)
					{ return this._startListener(pan); }

				if (!this._isActive)
					{ return null; }

				if (pan.isFinal)
					{ return this._stopListener(pan); }

				return this._swipeListener(pan);
			},
			_startListener: function _startListener(ref) {
				var distance = ref.distance;

				this.$el.classList.add('swipeout--no-transition');
				if (distance.y <= 5) {
					this._leftActionsWidth = this.$refs.left ? this.$refs.left.clientWidth : 0;
					this._rightActionsWidth = this.$refs.right ? this.$refs.right.clientWidth : 0;

					this._startLeft = this._distanceSwiped();
					this._isActive = true;
					this.$emit('active', true);
					clearTimeout(this._timer);
				}
			},
			_swipeListener: function _swipeListener(ref) {
				var offset = ref.offset;

				var newX = offset.x + this._startLeft;
				if (!this.$scopedSlots.left && newX > 0)
					{ return this._animateSlide(0); }

				if (!this.$scopedSlots.right && newX < 0)
					{ return this._animateSlide(0); }

				return this._animateSlide(offset.x + this._startLeft);
			},
			_stopListener: function _stopListener(ref) {
				var offset = ref.offset;
				var distance = ref.distance;

				this.$el.classList.remove('swipeout--no-transition');
				this._isActive = false;
				this.$emit('active', false);
				var newX = this._startLeft + offset.x;

				if ((this._startLeft === 0 && Math.abs(newX) <= this.threshold) || (distance.x >= this.threshold && ((this._startLeft > 0 && distance.x < this._leftActionsWidth) || (this._startLeft < 0 && distance.x < this._rightActionsWidth)))) // {
					{ return this._reveal(false); }
				return this._reveal(newX > 0 ? 'left' : 'right');
			},
			_reveal: function _reveal(dir, recalculateWidth) {
				if (this._isActive && areEqual(this.innerRevealed, dir))
					{ return; }

				if (dir && !this.$refs[dir])
					{ dir = false; }

				this.innerRevealed = dir;
				this.$emit('update:revealed', dir);

				// close
				if (!dir) {
					this._animateSlide(0);
					this.$emit('closed');
					return;
				}


				// left
				if (dir === 'left' && this.$refs.left) {
					this._leftActionsWidth = recalculateWidth ? clientWidth(this.$refs.left) : this._leftActionsWidth;
					this._animateSlide(this._leftActionsWidth);
					this.$emit('revealed', { side: 'left', close: this.closeActions });
					this.$emit('leftRevealed', { close: this.closeActions });
					return;
				}

				// right
				if (dir === 'right' && this.$refs.right) {
					this._rightActionsWidth = recalculateWidth ? clientWidth(this.$refs.right) : this._rightActionsWidth;
					this._animateSlide(-this._rightActionsWidth);
					this.$emit('revealed', { side: 'right', close: this.closeActions });
					this.$emit('rightRevealed', { close: this.closeActions });
				}
			},
			// shift actions
			_shiftLeftActions: function _shiftLeftActions(newX) {
				if (!this.$scopedSlots.left)
					{ return; }

				if (newX < 0)
					{ newX = 0; }

				var actions = this.$refs.left;
				var actionsWidth = this._leftActionsWidth;

				var progress = 1 - Math.min(newX / actionsWidth, 1);
				var deltaX = Math.min(newX, actionsWidth);

				var children = actions.children;
				var length = children.length;
				for (var i = 0; i < length; i++) {
					var child = children[i];
					var offsetLeft = actionsWidth - child.offsetLeft - child.offsetWidth;
					child.style.transform = translateX(deltaX + (offsetLeft * progress));

					if (length > 1)
						{ child.style.zIndex = "" + (length - i); }
				}
			},
			_shiftRightActions: function _shiftRightActions(newX) {
				if (!this.$scopedSlots.right)
					{ return; }

				if (newX > 0)
					{ newX = 0; }

				var actions = this.$refs.right;

				var actionsWidth = this._rightActionsWidth;

				var progress = 1 + Math.max(newX / actionsWidth, -1);
				var deltaX = Math.max(newX, -actionsWidth);
				var children = actions.children;

				for (var i = 0; i < children.length; i++) {
					var child = children[i];
					child.style.transform = translateX(deltaX - (child.offsetLeft * progress));
				}
			},
			_animateSlide: function _animateSlide(to) {
				var this$1 = this;

				cancelAnimationFrame(this._frame);
				this._frame = requestAnimationFrame(function () {
					this$1.$refs.content.style.transform = translateX(to);
					this$1._shiftLeftActions(to);
					this$1._shiftRightActions(to);
				});
			},
		},
		render: function render(h) {
			var content = [];
			var ref = this.$scopedSlots;
			var left = ref.left;
			var right = ref.right;
			var defaultScope = ref.default;

			if (left)
				{ content.push(
					h('div', {
						ref: 'left',
						staticClass: 'swipeout-left',
					}, left({
						close: this.closeActions,
					}))
				); }


			if (right)
				{ content.push(
					h('div', {
						ref: 'right',
						staticClass: 'swipeout-right',
					}, right({
						close: this.closeActions,
					}))
				); }


			content.push(
				h('div', {
					ref: 'content',
					staticClass: 'swipeout-content',
					directives: !this.disabled && (left || right) ? [{
						name: 'touch-pan',
						value: this._onPan,
						modifiers: {
							horizontal: true,
							mouse: true,
							prevent: !this.passiveListeners,
							mousePrevent: true,
						},
					}] : null,
				}, defaultScope ? defaultScope({
					revealLeft: this.revealLeft,
					revealRight: this.revealRight,
					disabled: this.disabled,
					close: this.closeActions,
					revealed: this.innerRevealed,
				}) : null)
			);

			return h('div', {
				staticClass: 'swipeout',
				class: { 'swipeout--disabled': this.disabled },
			}, content);
		},
		beforeDestroy: function beforeDestroy() {
			clearTimeout(this._timer);
			cancelAnimationFrame(this._frame);
		},
	};

	/* eslint-disable consistent-return */
	function objectWithoutProperties (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }

	var SwipeList = {
		name: 'SwipeList',
		props: {
			items: {
				type: Array,
				required: true,
			},
			itemKey: {
				type: String,
			},
			/**
			 * @deprecated since version 2.0 - use itemKey instead
			 */
			transitionKey: {
				type: String,
			},
			threshold: {
				type: Number,
				default: 45,
			},
			revealed: {
				type: Object,
			},
			disabled: {
				type: Boolean,
				default: false,
			},
			itemDisabled: {
				type: Function,
				default: function () { return false; },
			},
			passiveListeners: {
				type: Boolean,
				default: false,
			},
		},
		data: function data() {
			return {
				innerRevealed: this.revealed || {},
				rev: this.items.map(function () { return null; }),
			};
		},
		watch: {
			revealed: function revealed(val) {
				this.innerRevealed = val;
			},
			items: function items() {
				this._emitRevealed({});
			},
		},
		methods: {
			revealRight: function revealRight(index) {
				if (!this.$refs.items[index])
					{ return; }
				this.$refs.items[index].revealRight();
			},
			revealLeft: function revealLeft(index) {
				if (!this.$refs.items[index])
					{ return; }
				this.$refs.items[index].revealLeft();
			},
			close: function close(index) {
				if (!this.$refs.items)
					{ return; }

				if (index === undefined)
					{ return this.$refs.items.forEach(function (i) { return i.close(); }); }

				if (!this.$refs.items[index])
					{ return; }

				return this.$refs.items[index].close();
			},
			isRevealed: function isRevealed(index) {
				return this.innerRevealed[index] || false;
			},
			/**
			 * @deprecated use ```close``` instead
			 */
			closeActions: function closeActions(index) {
				this.close(index);
			},
			// private
			/*
			_updateRevealed(item, index, side) {
				const key = this._getItemKey(item, index);
				if (side)
					return this.$set(this.innerRevealed, key, side);
				return this.$delete(this.innerRevealed, key);
			},
			*/
			_onReveal: function _onReveal(item, index, event) {
				var obj;

				this.$emit('revealed', {
					index: index,
					item: item,
					side: event.side,
					close: event.close,
				});
				this._emitRevealed(Object.assign({}, this.innerRevealed,
					( obj = {}, obj[index] = event.side, obj )));
			},
			_onClose: function _onClose(item, index) {
				this.$emit('closed', {
					index: index,
					item: item,
				});
				var ref = this.innerRevealed;
				var omit = ref[index];
				var rest = objectWithoutProperties( ref, [String(index)] );
				var newRevealed = rest;
				this._emitRevealed(newRevealed);
			},
			_getItemKey: function _getItemKey(item, index) {
				var keyPropery = this.itemKey || this.transitionKey;
				if (keyPropery !== undefined)
					{ return item[this.itemKey || this.transitionKey]; }
				return index;
			},
			_emitRevealed: function _emitRevealed(val) {
				if (this.revealed !== undefined) {
					this.$emit('update:revealed', val);
					return;
				}
				this.innerRevealed = val;
			},
			__renderItem: function __renderItem(h, item, index) {
				var this$1 = this;

				var ref = this.$scopedSlots;
				var left = ref.left;
				var right = ref.right;
				var defaultScope = ref.default;
				var scopedSlots = {};

				if (left)
					{ scopedSlots.left = function (ref) {
						var close = ref.close;

						return left({ item: item, close: close, index: index });
						}; }

				if (right)
					{ scopedSlots.right = function (ref) {
						var close = ref.close;

						return right({ item: item, close: close, index: index });
						}; }

				scopedSlots.default = function (ref) {
					var close = ref.close;
					var disabled = ref.disabled;
					var revealLeft = ref.revealLeft;
					var revealRight = ref.revealRight;
					var revealed = ref.revealed;

					return h('div', {
					ref: 'itemsContent',
					on: {
						click: function () { return this$1.$emit('swipeout:click', item); },
					},
				},
				defaultScope({
					item: item,
					index: index,
					close: close,
					disabled: disabled,
					revealed: revealed,
					revealLeft: revealLeft,
					revealRight: revealRight,
				}));
				};

				return h(SwipeOut, {
					key: index,
					ref: 'items',
					refInFor: true,
					staticClass: 'swipeout-list-item',
					props: {
						disabled: this.disabled || this.itemDisabled(item),
						threshold: this.threshold,
						revealed: this.innerRevealed[index],
						passiveListeners: this.passiveListeners,
					},
					on: {
						revealed: function ($event) { return this$1._onReveal(item, index, $event); },
						leftRevealed: function ($event) { return this$1.$emit('leftRevealed', { index: index, item: item, close: $event.close }); },
						rightRevealed: function ($event) { return this$1.$emit('rightRevealed', { index: index, item: item, close: $event.close }); },
						closed: function ($event) { return this$1._onClose(item, index, $event); },
						active: function ($event) { return this$1.$emit('active', $event); },
					},
					scopedSlots: scopedSlots,
				});
			},
		},
		render: function render(h) {
			var this$1 = this;

			return h('div', {
				staticClass: 'swipeout-list',
				class: { 'swipeout--disabled': this.disabled },
			}, this.items.map(function (item, index) { return this$1.__renderItem(h, item, index); }));
		},
	};

	Vue.use({
		install: function install(V) {
			V.component('SwipeList', SwipeList);
			V.component('SwipeOut', SwipeOut);
		},
	});

	var index_umd = {
		SwipeList: SwipeList,
		SwipeOut: SwipeOut,
	};

	return index_umd;

})));
